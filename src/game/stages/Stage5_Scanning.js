export class Stage5_Scanning {
  constructor(container, gameManager) {
    this.container = container;
    this.gameManager = gameManager;
    this.totalSegments = 80;
    this.scannedSegments = 0;
    this.grid = [];
  }

  init() {
    this.render();
    this.attachEvents();
  }

  render() {
    const mapSVG = this.generateMapSVG();

    this.container.innerHTML = `
      <div class="stage-scanning">
        <div class="hud">
          <h1>TERRITORY SCANNING</h1>
          <div class="progress-bar-container glow-box">
            <div class="progress-bar" id="scan-progress"></div>
          </div>
          <div class="status-text">SCANNED: <span id="scan-count">0</span>/${this.totalSegments}</div>
        </div>
        
        <div class="map-container">
          <div class="light-map" style="background-image: url('${mapSVG}');"></div>
          <div class="grid-overlay" id="grid-container">
            <!-- Grid items generated by JS -->
          </div>
        </div>
      </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
      .stage-scanning {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #f0f4f8; /* Light background */
        color: #333;
        font-family: 'Orbitron', sans-serif;
      }
      .hud {
        margin-bottom: 20px;
        text-align: center;
        z-index: 10;
        position: relative;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px 20px;
        border-radius: 10px;
        border: 1px solid rgba(0, 100, 255, 0.2);
        box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      }
      .hud h1 {
        font-size: 1.2rem;
        margin: 0 0 10px 0;
        color: #0055aa;
      }
      .progress-bar-container {
        width: 300px;
        height: 20px;
        margin: 0 auto 5px auto;
        background: rgba(0,0,0,0.1);
        border: 1px solid rgba(0, 100, 255, 0.3);
        border-radius: 4px;
        overflow: hidden;
      }
      .progress-bar {
        width: 0%;
        height: 100%;
        background-color: #00f2ff;
        box-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        transition: width 0.2s;
      }
      .status-text {
        color: #0055aa;
        font-weight: bold;
      }
      .map-container {
        position: relative;
        width: 80vw;
        max-width: 800px;
        height: 60vh;
        border: 2px solid rgba(0, 100, 255, 0.3);
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 100, 255, 0.1);
        overflow: hidden;
        background: #fff;
      }
      .light-map {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        opacity: 0.9;
        z-index: 1;
      }
      .grid-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(8, 1fr);
        z-index: 2;
      }
      .grid-cell {
        background: #e0e5ec;
        border: 1px solid #d1d9e6;
        cursor: pointer;
        transition: opacity 0.5s ease, background-color 0.3s;
        position: relative;
      }
      .grid-cell:hover {
        background: #d1d9e6;
      }
      .grid-cell.revealed {
        opacity: 0;
        pointer-events: none;
      }
      .scan-glow {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(0, 242, 255, 0.6) 0%, transparent 70%);
        opacity: 0;
        pointer-events: none;
        animation: glow-flash 0.5s ease-out forwards;
        z-index: 3;
      }
      @keyframes glow-flash {
        0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
      }
      .bonus-item {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.2rem;
        font-weight: bold;
        color: #0055aa;
        text-shadow: 0 0 2px rgba(0, 242, 255, 0.5);
        pointer-events: none;
        animation: float-up 1s ease-out forwards;
        z-index: 4;
        white-space: nowrap;
      }
      @keyframes float-up {
        0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
        100% { opacity: 0; transform: translate(-50%, -150%) scale(1.2); }
      }
    `;
    this.container.appendChild(style);

    this.gridContainer = document.getElementById('grid-container');
    this.scanProgress = document.getElementById('scan-progress');
    this.scanCount = document.getElementById('scan-count');

    this.generateGrid();
  }

  generateGrid() {
    for (let i = 0; i < this.totalSegments; i++) {
      const cell = document.createElement('div');
      cell.classList.add('grid-cell');
      cell.dataset.index = i;

      // Pre-assign bonuses to some cells (e.g., 20% chance)
      if (Math.random() < 0.2) {
        cell.dataset.bonus = Math.random() < 0.5 ? 'ENERGY' : 'POINTS';
      }

      cell.addEventListener('click', (e) => this.handleScan(cell, e));
      this.gridContainer.appendChild(cell);
    }
  }

  attachEvents() {
    // Events are attached in generateGrid
  }

  handleScan(cell, event) {
    if (cell.classList.contains('revealed')) return;

    cell.classList.add('revealed');

    // Create glow effect at click position
    const glow = document.createElement('div');
    glow.classList.add('scan-glow');

    const rect = cell.getBoundingClientRect();
    const containerRect = this.gridContainer.getBoundingClientRect();

    glow.style.left = (rect.left - containerRect.left + rect.width / 2) + 'px';
    glow.style.top = (rect.top - containerRect.top + rect.height / 2) + 'px';
    glow.style.width = rect.width + 'px';
    glow.style.height = rect.height + 'px';
    glow.style.position = 'absolute';

    this.gridContainer.appendChild(glow);
    setTimeout(() => glow.remove(), 500);

    // Check for bonus
    if (cell.dataset.bonus) {
      this.spawnBonus(cell.dataset.bonus, rect, containerRect);
    }

    this.scannedSegments++;
    this.updateProgress();

    if (this.scannedSegments >= this.totalSegments) {
      setTimeout(() => this.completeStage(), 800);
    }
  }

  spawnBonus(type, cellRect, containerRect) {
    const bonus = document.createElement('div');
    bonus.classList.add('bonus-item');
    bonus.textContent = type === 'ENERGY' ? '+ENERGY' : '+100 PTS';
    bonus.style.color = type === 'ENERGY' ? '#00f2ff' : '#0055aa';

    bonus.style.left = (cellRect.left - containerRect.left + cellRect.width / 2) + 'px';
    bonus.style.top = (cellRect.top - containerRect.top + cellRect.height / 2) + 'px';

    this.gridContainer.appendChild(bonus);
    setTimeout(() => bonus.remove(), 1000);
  }

  updateProgress() {
    const percent = (this.scannedSegments / this.totalSegments) * 100;
    this.scanProgress.style.width = `${percent}%`;
    this.scanCount.textContent = this.scannedSegments;
  }

  completeStage() {
    // alert('TERRITORY FULLY SCANNED.');
    this.gameManager.nextStage();
  }

  generateMapSVG() {
    const width = 1000;
    const height = 700;
    let svgContent = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

    // Gradient definitions for relief shading
    svgContent += `<defs>`;
    svgContent += `<radialGradient id="hillShade" cx="30%" cy="30%">
      <stop offset="0%" style="stop-color:#e8f4f8;stop-opacity:1" />
      <stop offset="50%" style="stop-color:#b3d9e8;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#4a7c99;stop-opacity:1" />
    </radialGradient>`;
    svgContent += `<radialGradient id="valleyShade" cx="50%" cy="50%">
      <stop offset="0%" style="stop-color:#1a3d52;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#2d5a73;stop-opacity:1" />
    </radialGradient>`;
    svgContent += `</defs>`;

    // Background - Light blue water
    svgContent += `<rect width="100%" height="100%" fill="#d4e8f0"/>`;

    // Helper for organic terrain shapes
    const generateTerrain = (cx, cy, r, points = 20, variation = 40) => {
      let path = "";
      for (let i = 0; i < points; i++) {
        const angle = (Math.PI * 2 * i) / points;
        const noise = (Math.sin(angle * 3) * 0.3 + Math.cos(angle * 5) * 0.2);
        const dist = r + (Math.random() - 0.5) * variation + noise * 20;
        const x = cx + Math.cos(angle) * dist;
        const y = cy + Math.sin(angle) * dist;
        path += (i === 0 ? "M" : "L") + x.toFixed(1) + "," + y.toFixed(1);
      }
      return path + "Z";
    };

    // Create terrain features (hills/mountains)
    const terrainFeatures = [];
    for (let i = 0; i < 8; i++) {
      terrainFeatures.push({
        cx: Math.random() * width,
        cy: Math.random() * height,
        r: 80 + Math.random() * 120,
        elevation: Math.random()
      });
    }

    // Draw base terrain with shading
    terrainFeatures.forEach(feature => {
      const baseColor = feature.elevation > 0.5 ? "url(#hillShade)" : "#a8cfe0";
      svgContent += `<path d="${generateTerrain(feature.cx, feature.cy, feature.r)}" 
        fill="${baseColor}" stroke="none" opacity="0.6"/>`;
    });

    // Add detailed contour lines (multiple layers)
    terrainFeatures.forEach(feature => {
      const levels = 6 + Math.floor(feature.elevation * 4);
      for (let level = 0; level < levels; level++) {
        const r = feature.r - (level * (feature.r / levels));
        if (r < 15) continue;

        const intensity = 1 - (level / levels);
        const strokeColor = level === 0 ? "#1a3d52" : `rgba(26, 61, 82, ${0.3 + intensity * 0.4})`;
        const strokeWidth = level === 0 ? 1.2 : (level % 2 === 0 ? 0.8 : 0.5);

        svgContent += `<path d="${generateTerrain(feature.cx, feature.cy, r, 20, 15)}" 
          fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>`;
      }
    });

    // Add fine contour lines across entire map
    for (let y = 50; y < height; y += 40) {
      let path = `M0 ${y}`;
      for (let x = 0; x < width; x += 30) {
        const noise = Math.sin(x * 0.02 + y * 0.015) * 15 + Math.cos(x * 0.015) * 10;
        path += ` L${x} ${y + noise}`;
      }
      svgContent += `<path d="${path}" fill="none" stroke="rgba(74, 124, 153, 0.2)" stroke-width="0.5"/>`;
    }

    // Add depth shading (valleys)
    for (let i = 0; i < 4; i++) {
      const cx = Math.random() * width;
      const cy = Math.random() * height;
      const r = 60 + Math.random() * 80;
      svgContent += `<ellipse cx="${cx}" cy="${cy}" rx="${r}" ry="${r * 0.7}" 
        fill="url(#valleyShade)" opacity="0.3"/>`;
    }

    // Grid overlay (subtle)
    for (let x = 0; x < width; x += 100)
      svgContent += `<line x1="${x}" y1="0" x2="${x}" y2="${height}" 
        stroke="rgba(74, 124, 153, 0.15)" stroke-width="0.5" stroke-dasharray="3,3"/>`;
    for (let y = 0; y < height; y += 100)
      svgContent += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" 
        stroke="rgba(74, 124, 153, 0.15)" stroke-width="0.5" stroke-dasharray="3,3"/>`;

    // Peak markers
    terrainFeatures.forEach(feature => {
      if (feature.elevation > 0.6) {
        svgContent += `<circle cx="${feature.cx}" cy="${feature.cy}" r="3" fill="#1a3d52"/>`;
        svgContent += `<circle cx="${feature.cx}" cy="${feature.cy}" r="2" fill="#fff" opacity="0.5"/>`;
      }
    });

    svgContent += `</svg>`;
    return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgContent);
  }



  cleanup() {
    // No specific cleanup needed
  }
}
